//Jonas Himawan
//5/30/2025
//CSE 123
//P3: Spam Classifier
//TA: Cady Xia
//The Classifier class represents a decision tree classifier used for binary 
//classification tasks. The class can build a decision tree by either training 
//on labeled data or by loading an exisiting tree structure from a file. Once 
//the decision tree is created, the classifier object can predict labels for 
//new input data, save its structure, and test accuracy against known labels. 
import java.io.*;
import java.util.*;

public class Classifier {
    private ClassifierNode root;

    //Behaviors:
    // - Scanner Constructor for the Classifier class.
    // - Reads the file from a given scanner and loads a decision tree from it.
    // - The input "sc" cannot be null.
    // - The tree created cannot be null.
    // - Format of the input file represents a decision tree in a pre-order traversal format.
    // - Each decision node is represented by two lines:
    // - "Feature: <feature>" and "Threshold: <threshold>"
    // - Each leaf node is represented by a single line containing the label.
    // - The input of this method is the same as the ouput from the save method.
    //Exceptions:
    // - Throws IllegalArgumentException if the provided input "sc" is null.
    // - Throws IllegalStateException if the tree is still empty after processing the 
    //   provided input "sc".
    //Returns:
    // - None
    //Parameters:
    // - Scanner sc: Scanner representing input file of a decision tree in pre-order format 
    //   that will be loaded as a decision tree for this class.
    public Classifier(Scanner sc) {
        if(sc == null){
            throw new IllegalArgumentException();
        }
        root = buildTree(sc);
        if(root == null){
            throw new IllegalStateException();
        }
    }

    //Behaviors:
    // - Private helper method for the Scanner Constructor.
    // - Builds a decision tree from the input.
    // - Returns the decision tree created from the input.
    //Exceptions:
    // - None
    //Returns:
    // - A ClassifierNode that serves as the root of the decision tree.
    //Parameters:
    // - Scanner input: Scanner representing input file used to create a decision tree.
    private ClassifierNode buildTree(Scanner input){
        if (!input.hasNextLine()) {
            return null;
        }
        String line = input.nextLine();
        // If decision node
        if (line.startsWith("Feature: ")) {
            String feature = line.substring("Feature: ".length());
            //if (!input.hasNextLine()) return null;
            double threshold = Double.parseDouble(input.nextLine().
                                substring("Threshold: ".length()));

            ClassifierNode left = buildTree(input);
            ClassifierNode right = buildTree(input);
            return new ClassifierNode(feature, threshold, left, right);
        } else {
            // If leaf node
            return new ClassifierNode(line, null);
        }
    }
    
    //Behaviors:
    // - Two List Constructor for the Classifier class.
    // - Builds a decision tree through training with data and results.
    // - Updates the tree structure as needed.
    // - The data and results cannot be null, they must be the same size, and
    //   they can't be empty.
    //Exceptions:
    // - Throws IllegalArgumentException if data or results is null.
    // - Throws IllegalArgumentException if data and results are not the same size.
    // - Throws IllegalArgumentException if data or results is empty.
    //Returns:
    // - None
    //Parameters:
    // - List<TextBlock> data: List of input data objects for training.
    // - List<String> results: List of labels corresponding to each data object.
    public Classifier(List<TextBlock> data, List<String> results) {
        if((data == null || results == null) || (data.size() != results.size()) 
                                        || data.isEmpty() || results.isEmpty()){
            throw new IllegalArgumentException("Training model has an error");
        }
        root = new ClassifierNode(results.get(0), data.get(0));
        int size = data.size();
        for(int i = 1; i < size; i++){
            root = trainTree(data.get(i), results.get(i), root);
        }
    }

    //Behaviors:
    // - Helper method for the Two List Constructor for the Classifier class.
    // - Represents the in depth mechansim for training data and updating the decision tree.
    // - Returns a ClassifierNode of the updated tree.
    //Exceptions:
    // - None
    //Returns:
    // - A ClassifierNode representing the updated tree created through training.
    //Parameters:
    // - TextBlock newData: The new data object to add to the decision tree.
    // - String label: The label associated with the new data object.
    // - ClassifierNode currNode: The current node in the tree being processed.
    private ClassifierNode trainTree(TextBlock newData, String label, ClassifierNode currNode) {
        //If leaf
        if (currNode.left == null && currNode.right == null) {
            //Base case, if the leaf is equal
            if (currNode.leaf.equals(label)) {
                return currNode;
            } else {
                // If its a leaf and not equal
                String newFeature = newData.findBiggestDifference(currNode.data);
                double threshold = midpoint(newData.get(newFeature), 
                                    currNode.data.get(newFeature));
                // Create new decision node
                ClassifierNode newNode = new ClassifierNode(newFeature, threshold, 
                                                currNode.left, currNode.right);

                if (newData.get(newFeature) < threshold) {
                    newNode.left = new ClassifierNode(label, newData);
                    newNode.right = currNode;
                } else {
                    newNode.right = new ClassifierNode(label, newData);
                    newNode.left = currNode;
                }
                return newNode;
            }
        //If decision
        } else {
            //If decision & new data is less than the current threshold
            if (newData.get(currNode.feature) < currNode.threshold) {
                currNode.left = trainTree(newData, label, currNode.left);
            } else {
                //If decision & new data is more than the current threshold
                currNode.right = trainTree(newData, label, currNode.right);
            }
            return currNode;
        }
    }

    //Behaviors:
    // - Predicts the given input as a label using the classifier object.
    // - Returns a string representing the predicted label.
    // - The input cannot be null.
    //Exceptions:
    // - Throws IllegalArgumentException if input is null.
    //Returns:
    // - A String representing the predicted label for the input.
    //Parameters:
    // - TextBlock input: The data that will be classified.
    public String classify(TextBlock input) {
        if(input == null){
            throw new IllegalArgumentException("Input cannot be null");
        }
        return classify(input, root);
    }

    //Behaviors:
    // - Helper method for the classify method.
    // - In depth mechansim for using the classifier object to predict the label.
    // - Returns a string representing the predicted label.
    //Exceptions:
    // - None
    //Returns:
    // - A String representing the predicted label for the input.
    //Parameters:
    // - TextBlock input: The data being classified.
    // - ClassifierNode currRoot: The current node in the decision tree used for the prediction.
    private String classify(TextBlock input, ClassifierNode currRoot){
        if(currRoot.left == null && currRoot.right == null){
            return currRoot.leaf;
        }
        double inputVal = input.get(currRoot.feature);
        if(inputVal >= currRoot.threshold){
            return classify(input, currRoot.right);
        } else {
            return classify(input, currRoot.left);
        }
    }

    //Behaviors:
    // - Saves to the provided PrintStream in the pre-order traversal format.
    // - Each decision node prints "Feature: <feature>" and "Threshold: <threshold>" 
    //   on two lines.
    // - Each leaf node prints the label only.
    // - Provided PrintStream cannot be null.
    // - The output of this method is the same as the input file for the Scanner constructor 
    //   of this class.
    //Exceptions:
    // - Throws IllegalArgumentException if the PrintStream ps is null.
    //Returns:
    // - None
    //Parameters:
    // - PrintStream ps: The stream where the classifier will be saved.
    public void save(PrintStream ps) {
        if (ps == null) {
            throw new IllegalArgumentException("PrintStream cannot be null");
        }
        save(root, ps);
    }

    //Behaviors:
    // - Helper method for the save method.
    // - Saves to the provided PrintStream.
    // - Each decision node prints "Feature: <feature>" and "Threshold: <threshold>" 
    //   on two lines.
    // - Each leaf node prints the label only.
    //Exceptions:
    // - None
    //Returns:
    // - None
    //Parameters:
    // - ClassifierNode currRoot: The current node in the tree to save.
    // - PrintStream ps: The stream where the classifier will be saved.
    private void save(ClassifierNode currRoot, PrintStream output){
        if(currRoot != null){
            if(currRoot.left == null && currRoot.right == null){
                output.println(currRoot.leaf);
            } else {
                output.println("Feature: " + currRoot.feature);
                output.println("Threshold: " + currRoot.threshold);
                save(currRoot.left, output);
                save(currRoot.right, output);
            }
        }
    }


    //The ClassifierNode class is an inner class for Classifier.
    //It represents the nodes of the tree for the Classifier object.
    //Represents both features and lebels.
    private static class ClassifierNode {
        public final String feature;   
        public final String leaf;   
        public final double threshold;   
        public final TextBlock data;   

        public ClassifierNode left;        
        public ClassifierNode right;       

        //Behaviors:
        // - Constructor for the decision of the ClassifierNode object.
        // - Creates a decision node with a feature and threshold.
        //Exceptions:
        // - None.
        //Returns:
        // - None
        //Parameters:
        // - String feature: The feature to test at this node.
        // - double threshold: The threshold value to compare against.
        // - ClassifierNode left: The left child node.
        // - ClassifierNode right: The right child node.
        public ClassifierNode(String feature, double threshold, ClassifierNode left, 
                                                            ClassifierNode right) {
            this.feature = feature;
            this.threshold = threshold;
            this.left = left;
            this.right = right;
            this.leaf = null;
            this.data = null;
        }

        //Behaviors:
        // - Constructor for the leaf of the ClassifierNode object.
        // - Creates a leaf node with a label and associated data.
        //Exceptions:
        // - None
        //Returns:
        // - None
        //Parameters:
        // - String leaf: The classification label for this node.
        // - TextBlock data: The data used to reach this label.
        public ClassifierNode(String leaf, TextBlock data) {
            this.feature = null;
            this.threshold = 0.0;
            this.leaf = leaf;
            this.data = data;
        }
    }


    ////////////////////////////////////////////////////////////////////
    // PROVIDED METHODS - **DO NOT MODIFY ANYTHING BELOW THIS LINE!** //
    ////////////////////////////////////////////////////////////////////

    // Helper method to calcualte the midpoint of two provided doubles.
    private static double midpoint(double one, double two) {
        return Math.min(one, two) + (Math.abs(one - two) / 2.0);
    }    

    // Behavior: Calculates the accuracy of this model on provided Lists of 
    //           testing 'data' and corresponding 'labels'. The label for a 
    //           datapoint at an index within 'data' should be found at the 
    //           same index within 'labels'.
    // Exceptions: IllegalArgumentException if the number of datapoints doesn't match the number 
    //             of provided labels
    // Returns: a map storing the classification accuracy for each of the encountered labels when
    //          classifying
    // Parameters: data - the list of TextBlock objects to classify. Should be non-null.
    //             labels - the list of expected labels for each TextBlock object. 
    //             Should be non-null.
    public Map<String, Double> calculateAccuracy(List<TextBlock> data, List<String> labels) {
        // Check to make sure the lists have the same size (each datapoint has an expected label)
        if (data.size() != labels.size()) {
            throw new IllegalArgumentException(
                    String.format("Length of provided data [%d] doesn't match provided labels [%d]",
                                  data.size(), labels.size()));
        }
        
        // Create our total and correct maps for average calculation
        Map<String, Integer> labelToTotal = new HashMap<>();
        Map<String, Double> labelToCorrect = new HashMap<>();
        labelToTotal.put("Overall", 0);
        labelToCorrect.put("Overall", 0.0);
        
        for (int i = 0; i < data.size(); i++) {
            String result = classify(data.get(i));
            String label = labels.get(i);

            // Increment totals depending on resultant label
            labelToTotal.put(label, labelToTotal.getOrDefault(label, 0) + 1);
            labelToTotal.put("Overall", labelToTotal.get("Overall") + 1);
            if (result.equals(label)) {
                labelToCorrect.put(result, labelToCorrect.getOrDefault(result, 0.0) + 1);
                labelToCorrect.put("Overall", labelToCorrect.get("Overall") + 1);
            }
        }

        // Turn totals into accuracy percentage
        for (String label : labelToCorrect.keySet()) {
            labelToCorrect.put(label, labelToCorrect.get(label) / labelToTotal.get(label));
        }
        return labelToCorrect;
    }
}
